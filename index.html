<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HomeTerm</title>
  <link rel="icon" type="image/png" href="favicon.png" sizes="512x512" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Source+Code+Pro:wght@500&display=swap"
    rel="stylesheet" />
  <link rel="stylesheet" href="styles.css" />
</head>

<body class="dark">

  <main class="home">
    <section class="center">
      <div id="clock" class="clock">--:--</div>
      <div id="greeting" class="greeting">Good day</div>
    </section>
    <footer class="hint">Type any key to open terminal • Press Esc to close</footer>
  </main>

  <div id="terminal" class="terminal hidden" onclick="focusPrompt()">
    <div id="terminal-content"></div>
  </div>

  <!-- Optional inline manifest for file:// usage -->
  <script id="wallpapers-manifest" type="application/json">
    ["forest.jpg","lake.jpg","avatar.jpg","fuji.jpg","mfog.jpg","rice.jpg","river.jpg","road.jpg","rock.jpg","snow.jpg","vol.jpg"]
  </script>

  <script>
    // Wallpaper with DPR-aware picking and randomization
    (async function setWallpaper() {
      const DPR = Math.min(window.devicePixelRatio || 1, 3);
      const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      const needW = Math.round(vw * DPR), needH = Math.round(vh * DPR);

      const setBG = (url) => {
        document.body.style.backgroundImage = `url("${url}")`;
        document.body.classList.add('has-wallpaper');
      };

      let list = null;
      try {
        const el = document.getElementById('wallpapers-manifest');
        if (el && el.textContent.trim()) list = JSON.parse(el.textContent);
      } catch { }
      if (!list) {
        try {
          const res = await fetch('wallpapers/index.json', { cache: 'no-store' });
          if (res.ok) list = await res.json();
        } catch { }
      }

      let candidates = [];
      if (Array.isArray(list)) {
        for (const item of list) {
          if (typeof item === 'string') {
            const base = item.replace(/\.(\w+)$/, '');
            const ext = (item.match(/\.(\w+)$/) || [])[0] || '';
            candidates.push(
              `wallpapers/${base}@3x${ext}`,
              `wallpapers/${base}-3x${ext}`,
              `wallpapers/${base}@2x${ext}`,
              `wallpapers/${base}-2x${ext}`,
              `wallpapers/${base}${ext}`
            );
          } else if (item && item.variants) {
            const v = item.variants;
            if (DPR >= 3 && v['3x']) candidates.push(`wallpapers/${v['3x']}`);
            if (DPR >= 2 && v['2x']) candidates.push(`wallpapers/${v['2x']}`);
            if (v['1x']) candidates.push(`wallpapers/${v['1x']}`);
          }
        }
      } else {
        const names = ['wallpaper', 'background', 'bg', 'home', 'default', 'main', 'jw'];
        const exts = ['avif', 'webp', 'jpg', 'jpeg', 'png'];
        for (const n of names) for (const e of exts) {
          candidates.push(
            `wallpapers/${n}@3x.${e}`, `wallpapers/${n}-3x.${e}`,
            `wallpapers/${n}@2x.${e}`, `wallpapers/${n}-2x.${e}`,
            `wallpapers/${n}.${e}`
          );
        }
      }

      candidates = [...new Set(candidates)];
      shuffle(candidates); // ensure random choice each load

      let bestURL = null, bestPixels = 0;
      for (const url of candidates) {
        const meta = await loadInfo(url);
        if (!meta) continue;
        const pixels = meta.w * meta.h;
        if (pixels > bestPixels) { bestPixels = pixels; bestURL = url; }
        if (meta.w >= needW && meta.h >= needH) { setBG(url); return; }
      }
      if (bestURL) setBG(bestURL);

      function loadInfo(url) {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => resolve({ w: img.naturalWidth, h: img.naturalHeight, url });
          img.onerror = () => resolve(null);
          img.src = url + `?t=${Date.now()}`;
        });
      }
      function shuffle(a) {
        for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; }
        return a;
      }
    })();

    // Clock + greeting
    const clockEl = document.getElementById('clock');
    const greetEl = document.getElementById('greeting');
    const term = document.getElementById('terminal');
    const termContent = document.getElementById('terminal-content');

    function tick() {
      const now = new Date();
      const hh = String(now.getHours()).padStart(2, '0');
      const mm = String(now.getMinutes()).padStart(2, '0');
      clockEl.textContent = `${hh}:${mm}`;
      const d = now.toLocaleDateString(undefined, { weekday: 'long', year: 'numeric', month: 'short', day: 'numeric' });
      greetEl.textContent = `Good ${now.getHours() < 12 ? 'morning' : now.getHours() < 18 ? 'afternoon' : 'evening'} • ${d}`;
    }
    tick(); setInterval(tick, 30_000);

    // Terminal focus handling
    function getPrompt() {
      return document.getElementById('prompt-input') ||
        termContent.querySelector('input,[contenteditable="true"]');
    }
    function focusPromptHard() {
      const el = getPrompt();
      if (!el) return false;
      el.focus({ preventScroll: true });
      if ('selectionStart' in el) { const v = el.value; el.selectionStart = el.selectionEnd = v.length; }
      return true;
    }
    function showTerminal() {
      term.classList.remove('hidden'); term.classList.add('show');
      if (typeof window.focusPrompt === 'function') window.focusPrompt();
      let tries = 0;
      const t = setInterval(() => { if (focusPromptHard() || ++tries >= 10) clearInterval(t); }, 16);
    }
    function hideTerminal() { term.classList.remove('show'); term.classList.add('hidden'); }
    function isPrintable(e) { return e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey; }

    // Keep focus if prompt re-renders
    new MutationObserver(() => { if (term.classList.contains('show')) focusPromptHard(); })
      .observe(termContent, { childList: true, subtree: true });

    // Open terminal on key; forward first character; keep focus inside
    window.addEventListener('keydown', (e) => {
      const visible = term.classList.contains('show');

      if (!visible) {
        if (isPrintable(e) || e.key === 'Backspace' || e.key === 'Enter' || e.key === 'Tab') {
          e.preventDefault();
          const first = e.key;
          showTerminal();
          setTimeout(() => {
            const el = getPrompt(); if (!el) return;
            if (first === 'Tab') {
              // trigger CLI autocomplete right away
              el.focus();
              el.dispatchEvent(new KeyboardEvent('keydown', { key: 'Tab', bubbles: true }));
            } else if (isPrintable({ key: first, ctrlKey: false, metaKey: false, altKey: false })) {
              const s = el.selectionStart ?? el.value.length;
              const t = el.selectionEnd ?? el.value.length;
              if (typeof el.setRangeText === 'function') el.setRangeText(first, s, t, 'end');
              else el.value += first;
              el.dispatchEvent(new Event('input', { bubbles: true }));
            } else if (first === 'Backspace') {
              el.value = el.value.slice(0, -1);
              el.dispatchEvent(new Event('input', { bubbles: true }));
            }
            el.focus();
          }, 0);
        }
        return;
      }

      if (e.key === 'Escape') { e.preventDefault(); hideTerminal(); return; }
      if (!term.contains(document.activeElement)) focusPromptHard();
    });

    // Critical: capture Tab to prevent browser focus traversal, but let CLI receive it
    window.addEventListener('keydown', (e) => {
      if (!term.classList.contains('show')) return;
      if (e.key === 'Tab') {
        e.preventDefault(); // stop browser from moving focus
        const prompt = getPrompt();
        if (prompt && document.activeElement !== prompt) {
          prompt.focus({ preventScroll: true });
          if ('selectionStart' in prompt) {
            const v = prompt.value;
            prompt.selectionStart = prompt.selectionEnd = v.length;
          }
        }
        // do not stopPropagation; CLI input's keydown handler still runs
      }
    }, { capture: true });
  </script>

  <script src="src/constants.js"></script>
  <script src="src/utils.js"></script>
  <script src="src/localStorageUtils.js"></script>
  <script src="src/writers.js"></script>
  <script src="src/commands.js"></script>
  <script src="src/cli.js"></script>
</body>

</html>